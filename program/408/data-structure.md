# 数据结构

## 第一章绪论

### 算法的基本概念

算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

> [!tip] 提示
> 
> 程序 = 数据结构 + 算法

### 算法的特性

1. 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。

    > [!tip] 提示
    >
    > 算法必须是**有穷**的，而程序可以是**无穷**的。

2. 确定性：算法中每条指令必须有确切的含义，对于**相同的输入**只能得出**相同的输出**。
3. 可行性：算法中描述的操作都可以通过已经实现的**基本运算执行有限次**来实现。
4. 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
5. 输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

### 算法设计的要求

1. 正确性：算法应能正确地解决给定的问题。
2. 可读性：算法应具有良好的可读性，以保证在阅读算法的程序员能够容易地理解算法。

    > [!tip] 提示
    >
    > 即写注释

3. 健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. 高效率：时间复杂度低，在同样的计算精度下，算法应具有较高的执行效率，以保证在有限的时间内获得问题的解。
5. 低存储量需求：不费内存，空间复杂度低。

### 算法效率的度量

> 时间复杂度 + 空间复杂度

> [!tip] 复杂度排序
>
> $$
> O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < 0(n^n)
> $$
>
> 即：**常对幂指阶**

#### 算法时间复杂度

> T(n)

时间开销与问题规模 n 之间的关系。

1. 加法规则

    $$
    T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n), g(n)))
    $$

    多项相加，只保留最高阶的项，且系数变为1。

    > T(n)=n²+9999999 --> n²

2. 乘法规则

    $$
    T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
    $$

    多项相乘，都保留。

- 最坏时间复杂度：最坏情况下算法的时间复杂度；

- 平均时间复杂度：所有输入示 例等概率出现的情况下，算法的期望运行时间；

- 最好时间复杂度：最好情况下算法的时间复杂度。

> [!tip] 提示
>
> 评价算法复杂度一般只考虑最坏时间复杂度和平均时间复杂度。

#### 算法空间复杂度

> S(n)

空间开销（内存开销）与问题规模 n 之间的关系。

1. 原地工作

    一算法所需内存空间为常量，即无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为 $S(n) = 0(1)$

2. 数组

    一维数组：$S(n) = 0(n)$

    二维数组：$S(n) = 0(n^2)$

3. 函数递归调用

    空间复杂度 = 递归调用的深度

    $S(n) = 0(n)$

## 第二章线性表

### 线性表的定义和基本操作

#### 定义

1. 线性表是具有**相同**数据类型的 n(n≥0) 个数据元素的**有限序列**，其中 n 为**表长**，当 n=0 时线性表是一个**空表**。若用 L 命名线性表，则其一般表示为

    $$
    L = (a_1, a_2, ..., a_i, a_{i+1}, ..., a_n)
    $$

2. 几个概念

    - $a_i$ 是线性表中的“第i个”元素线性表中的位序
    - $a_1$ 是表头元素；$a_n$ 是表尾元素。
    - 除第一个元素外，每个元素有且仅有一个**直接前驱**；除最后一个元素外，每个元素有且仅有一个**直接后继**。

#### 操作

基本操作：

- `InitList(&L)`：**初始化**表。构造一个空的线性表 `L`，**分配内存空间**。
- `DestroyList(&L)`：**销毁**操作。销毁线性表，并**释放**线性表 `L`所占用的**内存空间**。
- `Listlnsert(&L,i,e)`：**插入**操作。在表 `L`中的第 `i`个位置上插入指定元素 `e`。
- `ListDelete(&L,i,&e)`：**删除**操作。删除表L中第 `i`个位置的元素，并用 `e`返回删除元素的值。
- `LocateElem(L)`：**按值查找**操作。在表 `L`中查找具有给定关键字值的元素。
- `GetElem(L,i)`：**按位查找**操作。获取表 `L`中第 `i`个立置的元素的值。

其他常用操作

- `Length(L)`：求表长。返回线性表L的长度，即 `L`中数据元素的个数。
- `PrintList(L)`：输出操作。按前后顺序输出线性表 `L`的所有元素值。
- `Empty(L)`：判空操作。若 `L`为空表，则返回 `true`，否则返回 `false`。

> [!tip] 提示
> 
> - 对数据的操作（记忆思路）—— 创销、增删改查。
> - 上述操作是抽象的。
> - 实际开发中，可根据实际需求定义其他的基本操作。
> - 函数名和参数的形式、命名都可改变。

### 线性表的顺序表示

#### 顺序表的定义

用**顺序存储**的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。

#### 顺序表的实现

##### 静态分配

> 定义数组

```c
# define MaxSize 10	// 定义最大长度
typedef struct {
    ElemType data[MaxSize];  // 用静态的“数组”存放数据元素
    int length;	 // 顺序表的当前长度
} Sqlist;  // 顺序表的类型定义
```

##### 动态分配

> 定义指针

```c
# define InitSize 10	// 顺序表的初始长度
typedef struct {
    ElemType *data;  // 指示动态分配数组的指针
    int MaxSize;  // 顺序表的最大容量
    int length;  // 顺序表的当前长度
} Sqlist;  // 顺序表的类型定义
```

```c
L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);
```

`malloc` 函数返回一个指针，需要强制转型为你定义的数据元素类型指针，用于申请一整片连续的存储空间。其函数的参数，指明要分配多大的连续内存空间。

顺序表存满时，可再用 `malloc` 动态拓展顺序表的最大容量。但需要将数据元素复制到新的存储区域，并用 `free` 函数释放原区域。

#### 顺序表的特点

1. 随机访问，即可以在 `O(1)` 时间内找到第 `i` 个元素。
2. 存储密度高，每个节点只存储数据元素。
3. 拓展容量不方便。（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
4. 插入、删除操作不方便，需要移动大量元素。

#### 基本操作

> 基于静态分配

> [!tip] 提示
>
> 好的算法，应该具有“健壮性”能处理异常情况，并给使用者反馈。

##### 插入

`Listlnsert(&L,i,e)`：插入操作。在表 `L`中的第 `i`个位置上插入指定元素 `e`。

```c
#include <stdio.h>

#define MaxSize 10  // 定义最大长度
typedef struct {
    int data[MaxSize];  // 用静态的“数组”存放数据元素
    int length;  // 顺序表的当前长度
} SqList;    // 顺序表的类型定义

void InitList(SqList *L) {
    L->length = 0;
}

void ListInsert(SqList *L, int i, int e) {
    // 判断 i 是否合法
    if (i < 1 || i > L->length + 1) {
        printf("插入位置不合法\n");
        return;
    }

    // 判断顺序表是否已满
    if (L->length >= MaxSize) {
        printf("顺序表已满，无法插入\n");
        return;
    }

    for (int j = L->length; j >= i; --j) {
        // 将第i个元素及之后的元素后移
        L->data[j] = L->data[j-1];
    }
    L->data[i-1] = e;  // 在第i个位置插入元素e
    L->length++;  // 顺序表长度加1
}

int main(void) {
    SqList L;  // 声明一个顺序表
    InitList(&L);  // 初始化顺序表
    ListInsert(&L, 1, 1); // 插入几个元素
    ListInsert(&L, 2, 2);

    printf("顺序表的长度为：%d\n", L.length);

    for (int i = 0; i < L.length; ++i) {
        printf("%d ", L.data[i]);
    }
    return 0;
}

```

时间复杂度

- 最好时间复杂度 = 0(1)；
- 最坏时间复杂度 = 0(n)；
- 平均时间复杂度 = n / 2。

##### 删除

```c
// 删除并返回被删除的元素
int ListDelete(SqList *L, int i) {
    // 判断 i 是否合法
    if (i < 1 || i > L->length) {
        printf("删除位置不合法\n");
        return -1;
    }

    int e = L->data[i-1];  // 被删除的元素
    for (int j = i; j <= L->length; ++j) {
        // 将第i个元素及之后的元素前移
        L->data[j-2] = L->data[j-1];
    }
    L->length--;  // 顺序
    return e;
}
```

时间复杂度

- 最好时间复杂度 = 0(1)；
- 最坏时间复杂度 = 0(n)；
- 平均时间复杂度 = n-1 / 2。

##### 按位查找

```c
int GetElem(SqList L, int i) {
    // 判断 i 是否合法
    if (i < 1 || i > L.length) {
        printf("查找位置不合法\n");
        return -1;
    }
    return L.data[i-1];  // 返回第 i 个元素
}
```

时间复杂度 = 0(1)。

##### 按值查找

```c
int LocateElem(SqList L, int e) {
    for (int i = 0; i < L.length; ++i) {
        if (L.data[i] == e) {
            return i+1;  // 返回元素 e
        }
    }
    return 0;  // 返回 0 表示未找到元素 e
}
```

时间复杂度

- 最好时间复杂度 = 0(1)；
- 最坏时间复杂度 = 0(n)；
- 平均时间复杂度 = n+1 / 2。

### 线性表的链式表示

#### 单链表

##### 定义

每个结点除了存放数据元素外，还要存储指向下一个节点的指针。

![image-20240615202427060](assets/image-20240615202427060.png)

- 优点：不要求大片连续空间，改变容量方便；
- 缺点：不可随机存取，要耗费一定空间存放指针。
